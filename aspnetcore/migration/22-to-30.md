---
title: Migruj z ASP.NET Core 2,2 do 3,0
author: rick-anderson
description: Dowiedz się, jak migrować projekt ASP.NET Core 2,2 do ASP.NET Core 3,0.
ms.author: riande
ms.custom: mvc
ms.date: 05/03/2020
no-loc:
- appsettings.json
- ASP.NET Core Identity
- cookie
- Cookie
- Blazor
- Blazor Server
- Blazor WebAssembly
- Identity
- Let's Encrypt
- Razor
- SignalR
uid: migration/22-to-30
ms.openlocfilehash: f9896e13df4518e405424332b330879e891ed130
ms.sourcegitcommit: d5fa39765959738eed4bcf5ee0b207cefddb4873
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 03/14/2021
ms.locfileid: "103460459"
---
# <a name="migrate-from-aspnet-core-22-to-30"></a>Migruj z ASP.NET Core 2,2 do 3,0

Przez [Scott Addie](https://github.com/scottaddie) i [Rick Anderson](https://twitter.com/RickAndMSFT)

W tym artykule wyjaśniono, jak zaktualizować istniejący projekt ASP.NET Core 2,2 do ASP.NET Core 3,0. Warto utworzyć nowy projekt ASP.NET Core 3,0, aby:

* Porównaj z kodem ASP.NET Core 2,2.
* Skopiuj odpowiednie zmiany do projektu ASP.NET Core 3,0.

## <a name="prerequisites"></a>Wymagania wstępne

# <a name="visual-studio"></a>[Program Visual Studio](#tab/visual-studio)

[!INCLUDE[](~/includes/net-core-prereqs-vs-3.0.md)]

# <a name="visual-studio-code"></a>[Visual Studio Code](#tab/visual-studio-code)

[!INCLUDE[](~/includes/net-core-prereqs-vsc-3.0.md)]

# <a name="visual-studio-for-mac"></a>[Visual Studio dla komputerów Mac](#tab/visual-studio-mac)

[!INCLUDE[](~/includes/net-core-prereqs-mac-3.0.md)]

---

## <a name="update-net-core-sdk-version-in-globaljson"></a>Aktualizacja zestaw .NET Core SDK wersji w global.jsna

Jeśli rozwiązanie jest oparte na [global.jsw](/dotnet/core/tools/global-json) pliku przeznaczonym dla konkretnej wersji zestaw .NET Core SDK, zaktualizuj jej `version` właściwość do wersji 3,0 zainstalowanej na maszynie:

```json
{
  "sdk": {
    "version": "3.0.100"
  }
}
```

## <a name="update-the-project-file"></a>Zaktualizuj plik projektu

### <a name="update-the-target-framework"></a>Aktualizowanie platformy docelowej

ASP.NET Core 3,0 i nowsze są uruchamiane tylko na platformie .NET Core. Ustaw [moniker platformy docelowej (TFM)](/dotnet/standard/frameworks) na `netcoreapp3.0` :

[!code-xml[](22-to-30/samples/Web1.csproj?highlight=4)]

### <a name="remove-obsolete-package-references"></a>Usuń przestarzałe odwołania do pakietu

Wiele pakietów NuGet nie jest produkowanych dla ASP.NET Core 3,0. Takie odwołania do pakietów powinny zostać usunięte z pliku projektu. Rozważmy następujący plik projektu dla aplikacji internetowej ASP.NET Core 2,2:

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <TargetFramework>netcoreapp2.2</TargetFramework>
    <AspNetCoreHostingModel>InProcess</AspNetCoreHostingModel>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.AspNetCore.App"/>
    <PackageReference Include="Microsoft.AspNetCore.Razor.Design" Version="2.2.0" PrivateAssets="All" />
  </ItemGroup>

</Project>
```

Zaktualizowany plik projektu dla ASP.NET Core 3,0:

[!code-xml[](22-to-30/samples/Web1.csproj?highlight=4)]

Zaktualizowany plik projektu ASP.NET Core 3,0:

* W `<PropertyGroup>` :
  * Aktualizuje TFM do `netcoreapp3.0`
  * Usuwa `<AspNetCoreHostingModel>` element. Aby uzyskać więcej informacji, zobacz [model hostingu w procesie](#in-process-hosting-model) w tym dokumencie.

* W `<ItemGroup>` :
  * `Microsoft.AspNetCore.App` jest usuwany. Aby uzyskać więcej informacji, zobacz temat [Informacje o strukturze](#framework-reference) w tym dokumencie.
  * `Microsoft.AspNetCore.Razor.Design` zostaje usunięty i na poniższej liście pakietów nie jest już generowany.

Aby wyświetlić pełną listę pakietów, które nie są już generowane, wybierz następującą listę rozwijaną:

<details>
    <summary>Kliknij, aby rozwinąć listę pakietów, które nie są już generowane</summary>
    <ul>
        <li>Microsoft. AspNetCore</li>
        <li>Microsoft. AspNetCore. All</li>
        <li>Microsoft. AspNetCore. App</li>
        <li>Microsoft.AspNetCore.Antiforgery</li>
        <li>Microsoft.AspNetCore.Authentication</li>
        <li>Microsoft.AspNetCore.Authentication.Abstractions</li>
        <li>Microsoft. AspNetCore. Authentication. Cookie wolumin</li>
        <li>Microsoft.AspNetCore.Authentication.Core</li>
        <li>Microsoft.AspNetCore.Authentication.OAuth</li>
        <li>Microsoft.AspNetCore.Authorization.Policy</li>
        <li>Microsoft. AspNetCore. Cookie Zasad</li>
        <li>Microsoft.AspNetCore.Cors</li>
        <li>Microsoft.AspNetCore.Diagnostics</li>
        <li>Microsoft.AspNetCore.Diagnostics.HealthChecks</li>
        <li>Microsoft. AspNetCore. HostFiltering</li>
        <li>Microsoft. AspNetCore. hosting</li>
        <li>Microsoft.AspNetCore.Hosting.Abstractions</li>
        <li>Microsoft.AspNetCore.Hosting.Server.Abstractions</li>
        <li>Microsoft.AspNetCore.Http</li>
        <li>Microsoft.AspNetCore.Http.Abstractions</li>
        <li>Microsoft.AspNetCore.Http.Connections</li>
        <li>Microsoft.AspNetCore.Http.Extensions</li>
        <li>Microsoft.AspNetCore.HttpOverrides</li>
        <li>Microsoft.AspNetCore.HttpsPolicy</li>
        <li>Microsoft. AspNetCore.Identity</li>
        <li>Microsoft.AspNetCore.Localization</li>
        <li>Microsoft.AspNetCore.Localization.Routing</li>
        <li>Microsoft. AspNetCore. MVC</li>
        <li>Microsoft.AspNetCore.Mvc.Abstractions</li>
        <li>Microsoft.AspNetCore.Mvc.Analyzers</li>
        <li>Microsoft.AspNetCore.Mvc.ApiExplorer</li>
        <li>Microsoft.AspNetCore.Mvc.Api.Analyzers</li>
        <li>Microsoft.AspNetCore.Mvc.Core</li>
        <li>Microsoft.AspNetCore.Mvc.Cors</li>
        <li>Microsoft.AspNetCore.Mvc.DataAnnotations</li>
        <li>Microsoft.AspNetCore.Mvc.Formatters.Json</li>
        <li>Microsoft.AspNetCore.Mvc.Formatters.Xml</li>
        <li>Microsoft.AspNetCore.Mvc.Localization</li>
        <li>Microsoft. AspNetCore. MVC.Razor</li>
        <li>Microsoft. AspNetCore. MVC. Razor .. ViewCompilation</li>
        <li>Microsoft. AspNetCore. MVC. Razor Page</li>
        <li>Microsoft.AspNetCore.Mvc.TagHelpers</li>
        <li>Microsoft.AspNetCore.Mvc.ViewFeatures</li>
        <li>Microsoft. AspNetCore.Razor</li>
        <li>Microsoft. AspNetCore. Razor . Środowiska uruchomieniowego</li>
        <li>Microsoft. AspNetCore. Razor . Zdefiniowanych</li>
        <li>Microsoft.AspNetCore.ResponseCaching</li>
        <li>Microsoft.AspNetCore.ResponseCaching.Abstractions</li>
        <li>Microsoft.AspNetCore.ResponseCompression</li>
        <li>Microsoft.AspNetCore.Rewrite</li>
        <li>Microsoft. AspNetCore. Routing</li>
        <li>Microsoft.AspNetCore.Routing.Abstractions</li>
        <li>Microsoft.AspNetCore.Server.HttpSys</li>
        <li>Microsoft.AspNetCore.Server.IIS</li>
        <li>Microsoft.AspNetCore.Server.IISIntegration</li>
        <li>Microsoft.AspNetCore.Server.Kestrel</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Core</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Https</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets</li>
        <li>Microsoft.AspNetCore.Session</li>
        <li>Microsoft. AspNetCore.SignalR</li>
        <li>Microsoft. AspNetCore. SignalR . Procesor</li>
        <li>Microsoft. AspNetCore. StaticFiles</li>
        <li>Microsoft.AspNetCore.WebSockets</li>
        <li>Microsoft.AspNetCore.WebUtilities</li>
        <li>Microsoft.Net.Http.Headers </li>
    </ul>
</details>

### <a name="review-breaking-changes"></a>Przejrzyj istotne zmiany

[Przejrzyj istotne zmiany](#break)

### <a name="framework-reference"></a>Dokumentacja struktury

Funkcje ASP.NET Core, które były dostępne za pomocą jednego z wymienionych powyżej pakietów, są dostępne w `Microsoft.AspNetCore.App` ramach udostępnionej struktury. *Platforma udostępniona* to zestaw zestawów (plików *dll* ), które są zainstalowane na komputerze i zawiera składnik środowiska uruchomieniowego oraz pakiet docelowy. Aby uzyskać więcej informacji, zobacz [udostępnioną strukturę](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/).

* Projekty przeznaczone dla `Microsoft.NET.Sdk.Web` zestawu SDK niejawnie odwołują się do `Microsoft.AspNetCore.App` struktury.

  Dla tych projektów nie są wymagane żadne dodatkowe odwołania:

  ```xml
  <Project Sdk="Microsoft.NET.Sdk.Web">
    <PropertyGroup>
      <TargetFramework>netcoreapp3.0</TargetFramework>
    </PropertyGroup>
      ...
  </Project>
  ```

* Projekty przeznaczone dla obiektów docelowych `Microsoft.NET.Sdk` lub `Microsoft.NET.Sdk.Razor` SDK powinny dodawać jawne `FrameworkReference` do `Microsoft.AspNetCore.App` :

  ```xml
  <Project Sdk="Microsoft.NET.Sdk.Razor">
    <PropertyGroup>
      <TargetFramework>netcoreapp3.0</TargetFramework>
    </PropertyGroup>

    <ItemGroup>
      <FrameworkReference Include="Microsoft.AspNetCore.App" />
    </ItemGroup>
      ...
  </Project>
  ```

#### <a name="framework-dependent-builds-using-docker"></a>Kompilacje zależne od platformy przy użyciu platformy Docker

Kompilacje zależne od platformy, które korzystają z pakietu, który jest zależny od ASP.NET Core [udostępnionej platformy](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/) mogą spowodować następujący błąd w czasie wykonywania:

```console
It was not possible to find any compatible framework version
The specified framework 'Microsoft.AspNetCore.App', version '3.0.0' was not found.
  - No frameworks were found.
```

`Microsoft.AspNetCore.App` jest strukturą udostępnioną zawierającą środowisko uruchomieniowe ASP.NET Core i jest obecna tylko w obrazie platformy Docker/ [rdzeń/ASPNET](https://hub.docker.com/_/microsoft-dotnet-core-aspnet/) . Zestaw 3,0 SDK zmniejsza rozmiar kompilacji zależnych od platformy przy użyciu ASP.NET Core, bez uwzględniania zduplikowanych kopii bibliotek, które są dostępne w środowisku współdzielonym. Jest to potencjalne oszczędności do 18 MB, ale wymaga, aby środowisko uruchomieniowe ASP.NET Core było obecne/zainstalowane w celu uruchomienia aplikacji.

Aby określić, czy aplikacja ma zależność (bezpośredni lub pośredni) w ASP.NET Core udostępnionej platformie, sprawdź *runtimeconfig.js* pliku wygenerowanego podczas kompilowania/publikowania aplikacji. Poniższy plik JSON przedstawia zależność od ASP.NET Core udostępnionej platformy:

```json
{
  "runtimeOptions": {
    "tfm": "netcoreapp3.0",
    "framework": {
      "name": "Microsoft.AspNetCore.App",
      "version": "3.0.0"
    },
    "configProperties": {
      "System.GC.Server": true
    }
  }
}
```

Jeśli aplikacja korzysta z platformy Docker, Użyj obrazu podstawowego zawierającego ASP.NET Core 3,0. Na przykład `docker pull mcr.microsoft.com/dotnet/core/aspnet:3.0`.

### <a name="add-package-references-for-removed-assemblies"></a>Dodaj odwołania do pakietu dla usuniętych zestawów

ASP.NET Core 3,0 usuwa niektóre zestawy, które były wcześniej częścią `Microsoft.AspNetCore.App` odwołania do pakietu. Aby wizualizować, które zestawy zostały usunięte, Porównaj te dwa udostępnione foldery struktury. Na przykład porównanie wersji 2.2.7 i 3.0.0:

![Porównanie zestawów wspólnych struktur](22-to-30/_static/assembly-diff.png)

Aby nadal korzystać z funkcji dostarczonych przez usunięte zestawy, należy odwołać się do 3,0 wersji odpowiednich pakietów:

* Aplikacja internetowa wygenerowana przez szablon z **kontami poszczególnych użytkowników** wymaga dodania następujących pakietów:

  [!code-xml[](22-to-30/samples/WebFull.csproj?highlight=9-13)]

* [Microsoft. EntityFrameworkCore](https://www.nuget.org/packages/Microsoft.EntityFrameworkCore)

  Aby uzyskać więcej informacji na temat odwoływania się do pakietu specyficznego dla dostawcy bazy danych, zobacz [dostawcy bazy danych](/ef/core/providers/index).

* Identity INTERFEJSU użytkownika

  Obsługę [ Identity interfejsu użytkownika](xref:security/authentication/identity) można dodać, odwołując się do [Microsoft. AspNetCore. Identity .. Pakiet interfejsu użytkownika](https://www.nuget.org/packages/Microsoft.AspNetCore.Identity.UI) .

* SPA usługi

  * [Microsoft. AspNetCore. SpaServices](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices)
  * [Microsoft. AspNetCore. SpaServices. Extensions](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices.Extensions)

* Uwierzytelnianie: obsługa przepływów uwierzytelniania innych firm jest dostępna jako pakiety NuGet:

  * Protokół OAuth w serwisie Facebook ([Microsoft. AspNetCore. Authentication. Facebook](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Facebook))
  * Google OAuth ([Microsoft. AspNetCore. Authentication. Google](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Google))
  * Uwierzytelnianie konta Microsoft ([Microsoft. AspNetCore. Authentication. MicrosoftAccount](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.MicrosoftAccount))
  * Uwierzytelnianie OpenID Connect Connect ([Microsoft. AspNetCore. Authentication. OpenIdConnect](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.OpenIdConnect))
  * Token okaziciela OpenID Connect Connect ([Microsoft. AspNetCore. Authentication. JwtBearer](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.JwtBearer))
  * Protokół OAuth usługi Twitter ([Microsoft. AspNetCore. Authentication. Twitter](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Twitter))
  * Uwierzytelnianie WsFederation ([Microsoft. AspNetCore. Authentication. WsFederation](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.WsFederation))

* Obsługa formatowania i negocjacji zawartości dla `System.Net.HttpClient` : pakiet NuGet [Microsoft. ASPNET. WebApi. Client](https://www.nuget.org/packages/Microsoft.AspNet.WebApi.Client/) oferuje przydatną rozszerzalność `System.Net.HttpClient` z użyciem interfejsów API, takich jak `ReadAsAsync` i `PostJsonAsync` .

* Razor Kompilacja środowiska uruchomieniowego: obsługa kompilacji widoków i stron przez środowisko uruchomieniowe Razor jest teraz częścią [Microsoft. AspNetCore. MVC. Razor . RuntimeCompilation](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation).

* `Newtonsoft.Json`Obsługa MVC (JSON.NET): obsługa używania MVC z `Newtonsoft.Json` jest teraz częścią programu [`Microsoft.AspNetCore.Mvc.NewtonsoftJson`](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson) .

## <a name="startup-changes"></a>Zmiany uruchamiania

Na poniższej ilustracji przedstawiono usunięte i zmienione wiersze w Razor aplikacji sieci Web ASP.NET Core 2,2:

![usunięte i zmienione wiersze w ASP.NET Core 2,2::: No-Loc (Razor)::: Web App](22-to-30/_static/startup2.2.png)

Na powyższym obrazie usunięty kod jest wyświetlany na czerwono. Usunięty kod nie pokazuje cookie kodu opcji, który został usunięty przed porównaniem plików.

Na poniższej ilustracji przedstawiono dodane i zmienione wiersze w Razor aplikacji sieci Web ASP.NET Core 3,0:

![dodane i zmienione wiersze w ASP.NET Core 3,0::: No-Loc (Razor)::: Web App](22-to-30/_static/startup3.0.png)

Na powyższym obrazie dodany kod jest wyświetlany w kolorze zielonym. Aby uzyskać informacje na temat następujących zmian:

* `services.AddMvc` Aby `services.AddRazorPages` uzyskać więcej, zobacz temat [Rejestrowanie usługi MVC](#mvc-service-registration) w tym dokumencie.
* `CompatibilityVersion`, zobacz <xref:mvc/compatibility-version> .
* `IHostingEnvironment` Aby `IWebHostEnvironment` uzyskać więcej, zobacz [ten anons usługi GitHub](https://github.com/dotnet/AspNetCore/issues/7749).
* `app.UseAuthorization` dodano do szablonów, aby pokazać oprogramowanie pośredniczące do zatwierdzania zamówień. Jeśli aplikacja nie korzysta z autoryzacji, możesz bezpiecznie usunąć połączenie z `app.UseAuthorization` .
* `app.UseEndpoints`, zobacz [ Razor strony](#razor-pages) lub [Migruj Startup.Configuruj](#migrate-startupconfigure) w tym dokumencie.

### <a name="analyzer-support"></a>Obsługa analizatora

Projekty, które są przeznaczone dla niejawnie przywoływanych `Microsoft.NET.Sdk.Web` analizatorów odwołań, które zostały wcześniej wysłane jako część pakietu [Microsoft. AspNetCore. MVC. analizatory](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Analyzers/) . Nie są wymagane żadne dodatkowe odwołania, aby je włączyć.

Jeśli Twoja aplikacja używa [analizatorów interfejsów API](xref:web-api/advanced/analyzers) , które zostały wcześniej dostarczone przy użyciu pakietu [Microsoft. AspNetCore. MVC. API. analizatory](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Api.Analyzers/) , edytuj plik projektu, aby odwoływać się do analizatorów dostarczonych w ramach zestawu SDK sieci Web platformy .NET Core:

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">
    <PropertyGroup>
        <TargetFramework>netcoreapp3.0</TargetFramework>
        <IncludeOpenAPIAnalyzers>true</IncludeOpenAPIAnalyzers>
    </PropertyGroup>

    ...
</Project>
```

### <a name="razor-class-library"></a>Razor Biblioteka klas

Razor Projekty biblioteki klas, które zapewniają składniki interfejsu użytkownika dla MVC, muszą ustawić `AddRazorSupportForMvc` Właściwość w pliku projektu:

```xml
<PropertyGroup>
  <AddRazorSupportForMvc>true</AddRazorSupportForMvc>
</PropertyGroup>
```

### <a name="in-process-hosting-model"></a>Model hostingu w procesie

Projekty są domyślne dla [modelu hostingu w procesie](xref:host-and-deploy/aspnet-core-module#in-process-hosting-model) w ASP.NET Core 3,0 lub nowszym. Opcjonalnie można usunąć `<AspNetCoreHostingModel>` Właściwość w pliku projektu, jeśli jej wartość jest `InProcess` .

## <a name="kestrel"></a>Kestrel

### <a name="configuration"></a>Konfigurowanie

Migruj konfigurację Kestrel do [konstruktora hosta sieci Web](#hostb) dostarczonego przez program `ConfigureWebHostDefaults` (*program.cs*):

```csharp
public static IHostBuilder CreateHostBuilder(string[] args) =>
    Host.CreateDefaultBuilder(args)
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.ConfigureKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseStartup<Startup>();
        });
```

Jeśli aplikacja tworzy hosta ręcznie przy użyciu `ConfigureWebHost` polecenia zamiast `ConfigureWebHostDefaults` , należy wywołać `UseKestrel` konstruktora hosta sieci Web:

```csharp
public static void Main(string[] args)
{
    var host = new HostBuilder()
        .UseContentRoot(Directory.GetCurrentDirectory())
        .ConfigureWebHost(webBuilder =>
        {
            webBuilder.UseKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseIISIntegration()
            .UseStartup<Startup>();
        })
        .Build();

    host.Run();
}
```

### <a name="connection-middleware-replaces-connection-adapters"></a>Oprogramowanie pośredniczące połączenia zastępuje karty połączeń

Adaptery połączeń ( `Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.IConnectionAdapter` ) zostały usunięte z Kestrel. Zamień karty połączeń na oprogramowanie pośredniczące połączenia. Oprogramowanie pośredniczące połączenia jest podobne do oprogramowania pośredniczącego HTTP w potoku ASP.NET Core, ale dla połączeń niższego poziomu. Rejestrowanie protokołu HTTPS i połączeń:

* Zostały przeniesione z kart połączeń do oprogramowania pośredniczącego połączenia.
* Te metody rozszerzające działają tak jak w poprzednich wersjach ASP.NET Core. 

Aby uzyskać więcej informacji, zobacz [przykład TlsFilterConnectionHandler w sekcji ListenOptions. Protocols artykułu Kestrel](../fundamentals/servers/kestrel.md?view=aspnetcore-3.0#listenoptionsprotocols).

### <a name="transport-abstractions-moved-and-made-public"></a>Abstrakcje transportu przenoszone i udostępniane publicznie

Warstwa transportu Kestrel została udostępniona jako interfejs publiczny w programie `Connections.Abstractions` . W ramach tych aktualizacji:

* `Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions` i skojarzone typy zostały usunięte.
* <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions.NoDelay> został przeniesiony z <xref:Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions> do opcji transportu.
* `Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions.Internal.SchedulingMode` został usunięty z <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions> .

Aby uzyskać więcej informacji, zobacz następujące zasoby w witrynie GitHub:

* [Abstrakcje sieci klienta/serwera (#10308 dotnet/AspNetCore)](https://github.com/dotnet/AspNetCore/issues/10308)
* [Zaimplementuj nowe abstrakcję odbiornika nimi i ponowne umieszczanie Kestrel na wierzchu (dotnet/AspNetCore #10321)](https://github.com/dotnet/AspNetCore/pull/10321)

### <a name="kestrel-request-trailer-headers"></a>Nagłówki naczepy żądania Kestrel

Dla aplikacji przeznaczonych dla wcześniejszych wersji ASP.NET Core:

* Kestrel dodaje nagłówki przegałęzień protokołu HTTP/1.1 do kolekcji nagłówków żądań.
* Przyczepy są dostępne po odczytaniu treści żądania na końcu.

Powoduje to pewne wątpliwości dotyczące niejednoznaczności między nagłówkami i przyczepami, dlatego przyczepy zostały przeniesione do nowej kolekcji ( `RequestTrailerExtensions` ) w 3,0.

Żądania protokołu HTTP/2 są następujące:

* Niedostępne w ASP.NET Core 2,2.
* Dostępne w 3,0 jako `RequestTrailerExtensions` .

Nowe metody rozszerzenia żądania są obecne w celu uzyskania dostępu do tych przyczep. Podobnie jak w przypadku protokołu HTTP/1.1, przyczepy są dostępne po odczytaniu treści żądania na końcu.

W przypadku wersji 3,0 `RequestTrailerExtensions` dostępne są następujące metody:

* `GetDeclaredTrailers`: Pobiera nagłówek żądania `Trailer` , który zawiera listę przyczep, które mają być oczekiwane po treści.
* `SupportsTrailers`: Wskazuje, czy żądanie obsługuje nagłówki przyczepy.
* `CheckTrailersAvailable`: Sprawdza, czy żądanie obsługuje przyczepy i czy są dostępne do odczytu. To sprawdzenie nie zakłada, że istnieją przyczepy do odczytu. Być może nie ma żadnych przyczep do odczytania `true` , nawet jeśli jest zwracany przez tę metodę.
* `GetTrailer`: Pobiera żądany końcowy nagłówek z odpowiedzi. Sprawdź `SupportsTrailers` przed wywołaniem `GetTrailer` lub <xref:System.NotSupportedException> może wystąpić, jeśli żądanie nie obsługuje końcowych nagłówków.

Aby uzyskać więcej informacji, zobacz [Put Zażądaj przyczep w osobnej kolekcji (#10410 dotnet/AspNetCore)](https://github.com/dotnet/AspNetCore/pull/10410).

### <a name="allowsynchronousio-disabled"></a>AllowSynchronousIO wyłączone

`AllowSynchronousIO` Włącza lub wyłącza synchroniczne interfejsy operacji we/wy, takie jak `HttpRequest.Body.Read` , `HttpResponse.Body.Write` i `Stream.Flush` . Te interfejsy API są źródłem zablokowania wątków prowadzącego do awarii aplikacji. W 3,0, `AllowSynchronousIO` jest domyślnie wyłączona. Aby uzyskać więcej informacji, zobacz [sekcję synchronicznych operacji we/wy w artykule Kestrel](../fundamentals/servers/kestrel.md?view=aspnetcore-3.0#synchronous-io).

Jeśli jest wymagana synchroniczna operacja we/wy, można ją włączyć, konfigurując `AllowSynchronousIO` opcję na używanym serwerze (podczas wywoływania `ConfigureKestrel` , na przykład, jeśli jest używany Kestrel). Należy pamiętać, że wszystkie serwery (Kestrel, HttpSys, TestServer itp.) mają własne `AllowSynchronousIO` Opcje, które nie wpłyną na inne serwery. Synchroniczne we/wy można włączyć dla wszystkich serwerów w poszczególnych żądaniach, korzystając z `IHttpBodyControlFeature.AllowSynchronousIO` opcji:

```csharp
var syncIOFeature = HttpContext.Features.Get<IHttpBodyControlFeature>();

if (syncIOFeature != null)
{
    syncIOFeature.AllowSynchronousIO = true;
}
```

Jeśli masz problemy z <xref:System.IO.TextWriter> implementacjami lub innymi strumieniami wywołującymi synchroniczne interfejsy API w operacji [Dispose](/dotnet/standard/garbage-collection/implementing-dispose), <xref:System.IO.Stream.DisposeAsync*> zamiast tego wywołaj nowy interfejs API.

Aby uzyskać więcej informacji, zobacz [[anons] AllowSynchronousIO wyłączone na wszystkich serwerach (dotnet/AspNetCore #7644)](https://github.com/dotnet/AspNetCore/issues/7644).

### <a name="output-formatter-buffering"></a>Buforowanie wyjściowego programu formatującego

[Newtonsoft.Jsw](https://www.newtonsoft.com/json), <xref:System.Xml.Serialization.XmlSerializer> i <xref:System.Runtime.Serialization.DataContractSerializer> oparte na danych wyjściowych elementy formatujące obsługują tylko serializacji synchroniczne. Aby zezwolić tym programom do pracy z ograniczeniami [AllowSynchronousIO](https://github.com/dotnet/aspnetcore/issues/7644) serwera, MVC buforuje dane wyjściowe tych elementów formatujących przed zapisaniem na dysku. W wyniku buforowania, MVC będzie zawierać nagłówek Content-Length, gdy odpowiada za pomocą tych elementów formatujących.

<xref:System.Text.Json> obsługuje Serializacja asynchroniczną, a w związku z tym, że `System.Text.Json` oparty na programie formatującego nie jest buforem. Rozważ użycie tego programu formatującego w celu zwiększenia wydajności.

Aby wyłączyć buforowanie, aplikacje można skonfigurować <xref:Microsoft.AspNetCore.Mvc.MvcOptions.SuppressOutputFormatterBuffering> w trakcie ich uruchamiania:

```csharp
services.AddControllers(options => options.SuppressOutputFormatterBuffering = true)
```

Należy zauważyć, że może to spowodować, że aplikacja zgłasza wyjątek czasu wykonywania, jeśli `AllowSynchronousIO` nie jest również skonfigurowana.

### <a name="microsoftaspnetcoreserverkestrelhttps-assembly-removed"></a>Zestaw Microsoft. AspNetCore. Server. Kestrel. https został usunięty

W ASP.NET Core 2,1 zawartość *Microsoft.AspNetCore.Server.Kestrel.Https.dll* została przeniesiona do *Microsoft.AspNetCore.Server.Kestrel.Core.dll*. To była nieprzerwana Aktualizacja przy użyciu `TypeForwardedTo` atrybutów. W przypadku 3,0 został usunięty pusty zestaw *Microsoft.AspNetCore.Server.Kestrel.Https.dll* i pakiet NuGet.

Biblioteki odwołujące się do [Microsoft. AspNetCore. Server. Kestrel. https](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) powinny aktualizować ASP.NET Core zależności do 2,1 lub nowszych.

Aplikacje i biblioteki ukierunkowane na ASP.NET Core 2,1 lub nowsze powinny usunąć wszystkie bezpośrednie odwołania do pakietu [Microsoft. AspNetCore. Server. Kestrel. https](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) .

<a id="jsonnet-support"></a>

## <a name="newtonsoftjson-jsonnet-support"></a>Obsługa Newtonsoft.Js(Json.NET)

W ramach pracy w celu [usprawnienia ASP.NET Core udostępnionej struktury](https://blogs.msdn.microsoft.com/webdev/2018/10/29/a-first-look-at-changes-coming-in-asp-net-core-3-0/) [Newtonsoft.Json (JSON.NET)](https://www.newtonsoft.com/json/help/html/Introduction.htm) został usunięty z ASP.NET Core udostępnionej platformy.

Domyślny serializator JSON dla ASP.NET Core jest teraz <xref:System.Text.Json> Nowy w programie .NET Core 3,0. Rozważ użycie, `System.Text.Json` gdy jest to możliwe. Jest wysoka wydajność i nie wymaga dodatkowej zależności biblioteki. Jednak od momentu, `System.Text.Json` gdy jest to nowe, może to oznaczać brak funkcji wymaganych przez aplikację. Aby uzyskać więcej informacji, zobacz [Jak przeprowadzić migrację z Newtonsoft.Js, aby System.Text.Js](/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to).

### <a name="use-newtonsoftjson-in-an-aspnet-core-30-signalr-project"></a>Używanie Newtonsoft.Jsw projekcie ASP.NET Core 3,0 SignalR

* Zainstaluj [pakiet Microsoft. AspNetCore. SignalR . Protocols. NewtonsoftJson](https://www.nuget.org/packages/Microsoft.AspNetCore.SignalR.Protocols.NewtonsoftJson) pakiet NuGet.

* Na kliencie należy utworzyć łańcuch `AddNewtonsoftJsonProtocol` wywołań metody do `HubConnectionBuilder` wystąpienia:

  ```csharp
  new HubConnectionBuilder()
      .WithUrl("/chathub")
      .AddNewtonsoftJsonProtocol(...)
      .Build();
  ```

* Na serwerze należy utworzyć łańcuch `AddNewtonsoftJsonProtocol` wywołania metody `AddSignalR` wywołania metody w `Startup.ConfigureServices` :

  ```csharp
  services.AddSignalR()
      .AddNewtonsoftJsonProtocol(...);
  ```

### <a name="use-newtonsoftjson-in-an-aspnet-core-30-mvc-project"></a>Używanie Newtonsoft.Jsw projekcie ASP.NET Core 3,0 MVC

* Zainstaluj [`Microsoft.AspNetCore.Mvc.NewtonsoftJson`](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson) pakiet.

* Aktualizacja `Startup.ConfigureServices` do wywołania `AddNewtonsoftJson` .

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson();
  ```

  `AddNewtonsoftJson` jest zgodny z nowymi metodami rejestracji usługi MVC:

  * `AddRazorPages`
  * `AddControllersWithViews`
  * `AddControllers`

  ```csharp
  services.AddControllers()
      .AddNewtonsoftJson();
  ```

  `Newtonsoft.Json` Ustawienia można ustawić w wywołaniu `AddNewtonsoftJson` :

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson(options =>
             options.SerializerSettings.ContractResolver =
                new CamelCasePropertyNamesContractResolver());
  ```

  **Uwaga:** Jeśli `AddNewtonsoftJson` Metoda jest niedostępna, upewnij się, że zainstalowano [`Microsoft.AspNetCore.Mvc.NewtonsoftJson`](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson) pakiet. Typowym błędem jest zainstalowanie [Newtonsoft.Jsw](https://www.nuget.org/packages/Newtonsoft.Json/) pakiecie zamiast [`Microsoft.AspNetCore.Mvc.NewtonsoftJson`](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson) pakietu.

Aby uzyskać więcej informacji, zobacz [dodawanie Newtonsoft.Jsna podstawie obsługi formatu JSON](xref:web-api/advanced/formatting#add-newtonsoftjson-based-json-format-support).

## <a name="mvc-service-registration"></a>Rejestracja usługi MVC

ASP.NET Core 3,0 dodaje nowe opcje rejestrowania scenariuszy MVC wewnątrz `Startup.ConfigureServices` .

Dostępne są trzy nowe metody rozszerzenia najwyższego poziomu związane z scenariuszami MVC `IServiceCollection` . Szablony wykorzystują te nowe metody zamiast `AddMvc` . Jednak `AddMvc` nadal zachowuje się tak, jak w poprzednich wersjach.

Poniższy przykład dodaje obsługę kontrolerów i funkcji związanych z interfejsem API, ale nie widoków ani stron. Szablon interfejsu API używa tego kodu:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllers();
}
```

Poniższy przykład dodaje obsługę kontrolerów, funkcji związanych z interfejsem API i widoków, ale nie stron. Szablon aplikacji sieci Web (MVC) używa tego kodu:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
}
```

Poniższy przykład dodaje obsługę Razor stron i minimalną obsługę kontrolera. Szablon aplikacji sieci Web używa tego kodu:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddRazorPages();
}
```

Nowe metody można również łączyć. Poniższy przykład jest odpowiednikiem wywołania `AddMvc` w ASP.NET Core 2,2:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
    services.AddRazorPages();
}
```

## <a name="routing-startup-code"></a>Kod uruchomienia routingu

Jeśli aplikacja wywołuje `UseMvc` lub `UseSignalR` migruje aplikację do [routingu punktów końcowych](xref:fundamentals/routing) , jeśli jest to możliwe. Aby zwiększyć zgodność routingu punktów końcowych z poprzednimi wersjami MVC, zostały przywrócone niektóre zmiany w generowaniu adresów URL wprowadzone w ASP.NET Core 2,2. Jeśli wystąpią problemy z użyciem routingu punktów końcowych w 2,2, należy oczekiwać ulepszeń w ASP.NET Core 3,0 z następującymi wyjątkami:

* Jeśli aplikacja implementuje `IRouter` lub dziedziczy po `Route` , należy użyć [DynamicRouteValuesTransformer](https://github.com/dotnet/AspNetCore.Docs/issues/12997) jako zamiennika.
* Jeśli aplikacja bezpośrednio uzyskuje dostęp `RouteData.Routers` do wewnątrz MVC do analizowania adresów URL, można ją zastąpić za pomocą [LinkParser. ParsePathByEndpointName](xref:Microsoft.AspNetCore.Routing.LinkParserEndpointNameAddressExtensions.ParsePathByEndpointName*). 
  * Zdefiniuj trasę przy użyciu nazwy trasy.
  * Użyj `LinkParser.ParsePathByEndpointName` i przekaż żądaną nazwę trasy.

Routing punktów końcowych obsługuje tę samą składnię wzorca trasy i funkcje tworzenia wzorców tras `IRouter` . Obsługa routingu punktów końcowych `IRouteConstraint` . Routing punktów końcowych obsługuje `[Route]` , `[HttpGet]` i inne atrybuty routingu MVC.

W przypadku większości aplikacji wymagane są jedynie `Startup` zmiany.

### <a name="migrate-startupconfigure"></a>Migrowanie Startup.Configuruj

Ogólne porady:

* Dodaj `UseRouting` .
* Jeśli aplikacja jest wywoływana `UseStaticFiles` , umieść `UseStaticFiles` **przed** `UseRouting` .
* Jeśli aplikacja używa funkcji uwierzytelniania/autoryzacji, takich jak `AuthorizePage` lub `[Authorize]` , należy umieścić wywołanie do `UseAuthentication` i `UseAuthorization` : **po**, `UseRouting` i `UseCors` , ale przed `UseEndpoints` :

  ```csharp
  public void Configure(IApplicationBuilder app)
  {
    ...

    app.UseStaticFiles();

    app.UseRouting();
    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints => {
       endpoints.MapControllers();
    });
  ```

* Zamień `UseMvc` lub `UseSignalR` na `UseEndpoints` .
* Jeśli aplikacja używa scenariuszy [CORS](xref:security/cors) , takich jak `[EnableCors]` , należy umieścić wywołanie `UseCors` przed dowolnym innym oprogramowanie pośredniczące, które używa mechanizmu CORS (na przykład Umieść `UseCors` przed `UseAuthentication` , `UseAuthorization` , i `UseEndpoints` ).
* Zamień `IHostingEnvironment` na `IWebHostEnvironment` i Dodaj `using` instrukcję dla <xref:Microsoft.Extensions.Hosting?displayProperty=fullName> przestrzeni nazw.
* Zamień `IApplicationLifetime` na <xref:Microsoft.Extensions.Hosting.IHostApplicationLifetime> ( <xref:Microsoft.Extensions.Hosting?displayProperty=fullName> przestrzeń nazw).
* Zamień `EnvironmentName` na <xref:Microsoft.Extensions.Hosting.Environments> ( <xref:Microsoft.Extensions.Hosting?displayProperty=fullName> przestrzeń nazw).

Poniższy kod jest przykładem `Startup.Configure` w typowej aplikacji ASP.NET Core 2,2:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseAuthentication();

    app.UseSignalR(hubs =>
    {
        hubs.MapHub<ChatHub>("/chat");
    });

    app.UseMvc(routes =>
    {
        routes.MapRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

Po zaktualizowaniu poprzedniego `Startup.Configure` kodu:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseRouting();

    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>("/chat");
        endpoints.MapControllerRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

> [!WARNING]
> W przypadku większości aplikacji wywołania `UseAuthentication` , `UseAuthorization` i `UseCors` muszą znajdować się między wywołaniami `UseRouting` i, `UseEndpoints` Aby obowiązywać.

### <a name="health-checks"></a>Kontrole kondycji

Kontrole kondycji korzystają z routingu punktu końcowego z hostem ogólnym. W programie `Startup.Configure` Wywołaj program `MapHealthChecks` Endpoint Builder z adresem URL punktu końcowego lub ścieżką względną:

```csharp
app.UseEndpoints(endpoints =>
{
    endpoints.MapHealthChecks("/health");
});
```

Punkty końcowe sprawdzania kondycji mogą:

* Określ jeden lub więcej dozwolonych hostów/portów.
* Wymagaj autoryzacji.
* Wymagaj mechanizmu CORS.

Aby uzyskać więcej informacji, zobacz <xref:host-and-deploy/health-checks>.

### <a name="security-middleware-guidance"></a>Wskazówki dotyczące oprogramowania pośredniczącego zabezpieczeń

Obsługa autoryzacji i mechanizmu CORS jest ujednolicona dla podejścia [pośredniczącego](xref:fundamentals/middleware/index) . Pozwala to korzystać z tego samego oprogramowania pośredniczącego i funkcji w tych scenariuszach. Zaktualizowane oprogramowanie pośredniczące autoryzacji jest dostępne w tej wersji, a oprogramowanie do obsługi mechanizmu CORS jest ulepszone, aby można było zrozumieć atrybuty używane przez kontrolery MVC.

#### <a name="cors"></a>CORS

Wcześniej mechanizm CORS może być trudny do skonfigurowania. Oprogramowanie pośredniczące zostało dostarczone do użycia w niektórych przypadkach użycia, ale filtry MVC były przeznaczone do użycia **bez** oprogramowania pośredniczącego w innych przypadkach użycia. W ASP.NET Core 3,0 zalecamy, aby wszystkie aplikacje wymagające mechanizmu CORS korzystały z oprogramowania pośredniczącego CORS wspólnie z routingiem punktów końcowych. `UseCors` można podać przy użyciu domyślnych zasad i można `[EnableCors]` `[DisableCors]` użyć atrybutów, aby zastąpić zasady domyślne, gdy jest to wymagane.

W poniższym przykładzie:

* Funkcja CORS jest włączona dla wszystkich punktów końcowych z `default` nazwanymi zasadami.
* `MyController`Klasa wyłącza funkcję CORS z `[DisableCors]` atrybutem.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseCors("default");

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[DisableCors]
public class MyController : ControllerBase
{
    ...
}
```

#### <a name="authorization"></a>Autoryzacja

We wcześniejszych wersjach ASP.NET Core Obsługa autoryzacji była świadczona za pośrednictwem `[Authorize]` atrybutu. Oprogramowanie pośredniczące autoryzacji nie jest dostępne. W ASP.NET Core 3,0 wymagane jest oprogramowanie pośredniczące autoryzacji. Zalecamy natychmiastowe umieszczenie oprogramowania pośredniczącego autoryzacji ASP.NET Core ( `UseAuthorization` ) `UseAuthentication` . Oprogramowanie pośredniczące autoryzacji można także skonfigurować przy użyciu zasad domyślnych, które mogą zostać zastąpione.

W ASP.NET Core 3,0 lub nowszej `UseAuthorization` jest wywoływana w `Startup.Configure` , a następujące elementy `HomeController` wymagają zalogowanego użytkownika:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

public class HomeController : Controller
{
    [Authorize]
    public IActionResult BuyWidgets()
    {
        ...
    }
}
```

W przypadku korzystania z routingu punktów końcowych zalecamy skonfigurowanie usługi <xref:Microsoft.AspNetCore.Mvc.Authorization.AuthorizeFilter> i zamianę opartej na oprogramowaniu pośredniczącym autoryzacji.  Jeśli aplikacja używa `AuthorizeFilter` jako filtru globalnego w MVC, zalecamy refaktoryzację kodu w celu zapewnienia zasad w wywołaniu `AddAuthorization` .

`DefaultPolicy`Początkowo skonfigurowano wymaganie uwierzytelniania, dlatego nie jest wymagana żadna dodatkowa konfiguracja. W poniższym przykładzie punkty końcowe MVC są oznaczone jako `RequireAuthorization` tak, że wszystkie żądania muszą być autoryzowane na podstawie `DefaultPolicy` . Jednak zezwala na `HomeController` dostęp bez logowania użytkownika do aplikacji z powodu `[AllowAnonymous]` :

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute().RequireAuthorization();
    });
}

[AllowAnonymous]
public class HomeController : Controller
{
    ...
}
```

### <a name="authorization-for-specific-endpoints"></a>Autoryzacja dla określonych punktów końcowych

Autoryzację można również skonfigurować dla określonych klas punktów końcowych. Poniższy kod stanowi przykład konwersji aplikacji MVC, która skonfigurowała globalne `AuthorizeFilter` dla aplikacji z określonymi zasadami wymagającymi autoryzacji:

[!code-csharp[](22-to-30/samples/Startup.cs?name=snippet&highlight=8-9,21-22,26-27,53-54)]

Zasady można także dostosować. `DefaultPolicy`Skonfigurowano wymaganie uwierzytelniania:

[!code-csharp[](22-to-30/samples/Startup2.cs?name=snippet&highlight=21-26,52)]

[!code-csharp[](22-to-30/samples/HomeController.cs?name=snippet)]

Alternatywnie wszystkie punkty końcowe można skonfigurować tak, aby wymagały autoryzacji, bez konieczności `[Authorize]` `RequireAuthorization` konfigurowania `FallbackPolicy` . `FallbackPolicy`Różni się od `DefaultPolicy` . `DefaultPolicy`Jest wyzwalany przez `[Authorize]` lub `RequireAuthorization` , podczas gdy `FallbackPolicy` jest wyzwalane, gdy nie ustawiono żadnych innych zasad. `FallbackPolicy` jest początkowo skonfigurowana do zezwalania na żądania bez autoryzacji.

Poniższy przykład jest taki sam jak w poprzednim `DefaultPolicy` przykładzie, ale używa `FallbackPolicy` do zawsze Wymagaj uwierzytelniania we wszystkich punktach końcowych, z wyjątkiem sytuacji, gdy `[AllowAnonymous]` jest określony:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    ...

    services.AddAuthorization(options =>
    {
        options.FallbackPolicy = new AuthorizationPolicyBuilder()
          .RequireAuthenticatedUser()
          .Build();
    });
}

public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[AllowAnonymous]
public class HomeController : Controller
{
    ...
}
```

Autoryzacja przez oprogramowanie pośredniczące działa bez struktury, która ma konkretną wiedzę o autoryzacji. Na przykład [kontrole kondycji](xref:host-and-deploy/health-checks) nie mają określonej znajomości autoryzacji, ale kontrole kondycji mogą mieć konfigurowalne zasady autoryzacji stosowane przez oprogramowanie pośredniczące.

Ponadto każdy punkt końcowy może dostosować wymagania dotyczące autoryzacji. W poniższym przykładzie program `UseAuthorization` przetwarza autoryzację przy użyciu `DefaultPolicy` , ale `/healthz` punkt końcowy sprawdzania kondycji wymaga `admin` użytkownika:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints
            .MapHealthChecks("/healthz")
            .RequireAuthorization(new AuthorizeAttribute(){ Roles = "admin", });
    });
}
```

Ochrona jest zaimplementowana w niektórych scenariuszach. Punkty końcowe oprogramowanie pośredniczące zgłasza wyjątek, jeśli zasady autoryzacji lub mechanizmu CORS zostały pominięte ze względu na brak oprogramowania pośredniczącego. Obsługa analizatora, aby zapewnić dodatkową opinię na temat niedziałania konfiguracji.

#### <a name="custom-authorization-handlers"></a>Niestandardowe programy obsługi autoryzacji

Jeśli aplikacja używa niestandardowych [programów obsługi autoryzacji](xref:security/authorization/policies#authorization-handlers), routing punktu końcowego przekazuje inny typ zasobu do obsługi niż MVC. Programy obsługi, które oczekują, że zasób kontekstu procedury obsługi autoryzacji ma typ <xref:Microsoft.AspNetCore.Mvc.Filters.AuthorizationFilterContext> (typ zasobu [dostarczony przez filtry MVC](xref:security/authorization/policies#access-mvc-request-context-in-handlers)) będzie musiał zostać zaktualizowany w celu obsługi zasobów typu <xref:Microsoft.AspNetCore.Routing.RouteEndpoint> (typ zasobu podany dla programów obsługi autoryzacji według routingu punktów końcowych).

MVC nadal używa `AuthorizationFilterContext` zasobów, więc jeśli aplikacja używa filtrów autoryzacji MVC wraz z autoryzacją routingu punktu końcowego, może być konieczne obsługę obu typów zasobów.

### SignalR

Mapowanie SignalR centrów odbywa się teraz w obrębie `UseEndpoints` .

Mapuj każde centrum za pomocą `MapHub` . Tak jak w poprzednich wersjach, każde centrum jest jawnie wymienione.

W poniższym przykładzie `ChatHub` SignalR Dodano obsługę centrum:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>();
    });
}
```

Istnieje nowa opcja kontrolowania limitów rozmiaru komunikatów od klientów. Na przykład w `Startup.ConfigureServices` :

```csharp
services.AddSignalR(hubOptions =>
{
    hubOptions.MaximumReceiveMessageSize = 32768;
});
```

W ASP.NET Core 2,2 można ustawić `TransportMaxBufferSize` i, który efektywnie kontroluje maksymalny rozmiar komunikatu. W ASP.NET Core 3,0 ta opcja teraz kontroluje maksymalny rozmiar tylko przed zaobserwowaniem wartości.

### <a name="mvc-controllers"></a>Kontrolery MVC

Teraz trwa mapowanie kontrolerów `UseEndpoints` .

Dodaj `MapControllers` , jeśli aplikacja używa routingu atrybutów. Ponieważ Routing obejmuje obsługę wielu struktur w ASP.NET Core 3,0 lub nowszych, Dodawanie kontrolerów z obsługą atrybutu jest zgodą.

Zastąp następujące:

* `MapRoute` się `MapControllerRoute`
* `MapAreaRoute` się `MapAreaControllerRoute`

Ponieważ Routing obejmuje teraz obsługę więcej niż tylko MVC, terminologia zmieniła się w taki sposób, że te metody jasno określają to, co robią. Trasy konwencjonalne, takie jak `MapControllerRoute` / `MapAreaControllerRoute` / `MapDefaultControllerRoute` są stosowane w kolejności, w jakiej zostały dodane. Najpierw umieść bardziej szczegółowe trasy (takie jak trasy dla obszaru).

W poniższym przykładzie:

* `MapControllers` dodaje obsługę kontrolerów z routingiem z atrybutami.
* `MapAreaControllerRoute` dodaje konwencjonalne trasy dla kontrolerów w obszarze.
* `MapControllerRoute` dodaje konwencjonalne trasy dla kontrolerów.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllers();
        endpoints.MapAreaControllerRoute(
            "admin",
            "admin",
            "Admin/{controller=Home}/{action=Index}/{id?}");
        endpoints.MapControllerRoute(
            "default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

#### <a name="async-suffix-removal-from-controller-action-names"></a>Usuwanie sufiksu asynchronicznego z nazw akcji kontrolera

W ASP.NET Core 3,0 ASP.NET Core MVC usuwa `Async` sufiks z nazw akcji kontrolera. Ta nowa wartość domyślna ma wpływ na generowanie routingu i linków. Na przykład:

```csharp
public class ProductsController : Controller
{
    public async Task<IActionResult> ListAsync()
    {
        var model = await _dbContext.Products.ToListAsync();
        return View(model);
    }
}
```

Przed ASP.NET Core 3,0:

* Do powyższej akcji można uzyskać dostęp w marszrucie *produkty/ListAsync* .
* Wymagana jest generacja linku określająca `Async` sufiks. Na przykład:

    ```cshtml
    <a asp-controller="Products" asp-action="ListAsync">List</a>
    ```

W ASP.NET Core 3,0:

* Poprzednią akcję można uzyskać przy użyciu trasy *produkty/lista* .
* Generowanie łącza nie wymaga określenia `Async` sufiksu. Na przykład:

    ```cshtml
    <a asp-controller="Products" asp-action="List">List</a>
    ```

Ta zmiana nie ma wpływu na nazwy określone przy użyciu [`[ActionName]`](/dotnet/api/microsoft.aspnetcore.mvc.actionnameattribute) atrybutu. Zachowanie domyślne można wyłączyć przy użyciu następującego kodu w programie `Startup.ConfigureServices` :

```csharp
services.AddMvc(options =>
    options.SuppressAsyncSuffixInActionNames = false);
```

#### <a name="changes-to-link-generation"></a>Zmiany generacji linku

Zgodnie z opisem w dokumentacji dotyczącej [różnic między wcześniejszymi wersjami routingu](xref:fundamentals/routing#differences-from-earlier-versions-of-routing)istnieją pewne różnice w generowaniu linków ( `Url.Link` na przykład przy użyciu i podobne interfejsy API). Są one następujące:

* Domyślnie podczas korzystania z routingu punktów końcowych wielkość liter w parametrach trasy w wygenerowanych identyfikatorach URI nie musi być zachowywana. Takie zachowanie może być kontrolowane za pomocą `IOutboundParameterTransformer` interfejsu.
* Generowanie identyfikatora URI dla nieprawidłowej trasy (kontroler/akcja lub strona, która nie istnieje) spowoduje utworzenie pustego ciągu w ramach routingu punktu końcowego zamiast tworzenia nieprawidłowego identyfikatora URI.
* Wartości otoczenia (parametry trasy z bieżącego kontekstu) nie są automatycznie używane w generacji linków z routingiem punktów końcowych. Wcześniej podczas generowania linku do innej akcji (lub strony) nieokreślone wartości trasy byłyby wywnioskowane na podstawie *bieżących* wartości w otoczeniu tras. W przypadku korzystania z routingu punktów końcowych wszystkie parametry trasy muszą być jawnie określone podczas generowania łącza.

### <a name="razor-pages"></a>Razor Page

Na Razor stronach mapowania teraz odbywa się wewnątrz `UseEndpoints` .

Dodaj `MapRazorPages` , jeśli aplikacja używa Razor stron. Ponieważ Routing punktów końcowych obejmuje obsługę wielu struktur, Dodawanie Razor stron jest teraz zgodą.

W następującej `Startup.Configure` metodzie program `MapRazorPages` dodaje obsługę Razor stron:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapRazorPages();
    });
}
```

### <a name="use-mvc-without-endpoint-routing"></a>Korzystanie z MVC bez routingu punktu końcowego

Użycie MVC przez `UseMvc` lub `UseMvcWithDefaultRoute` w ASP.NET Core 3,0 wymaga jawnej zgody w wewnątrz `Startup.ConfigureServices` . Jest to wymagane, ponieważ MVC musi wiedzieć, czy może polegać na oprogramowaniu pośredniczącym i oprogramowaniu CORS podczas inicjacji. Zostanie dostarczony Analizator ostrzegający, czy aplikacja próbuje użyć nieobsługiwanej konfiguracji.

Jeśli aplikacja wymaga starszej `IRouter` obsługi, należy wyłączyć `EnableEndpointRouting` Korzystanie z następujących metod w programie `Startup.ConfigureServices` :

```csharp
services.AddMvc(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllers(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllersWithViews(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddRazorPages().AddMvcOptions(options => options.EnableEndpointRouting = false);
```

### <a name="health-checks"></a>Kontrole kondycji

Kontrole kondycji mogą służyć jako oprogramowanie *do przesyłania i kierowania* punktów końcowych.

Dodawanie `MapHealthChecks` do korzystania z kontroli kondycji przy użyciu routingu punktu końcowego. `MapHealthChecks`Metoda akceptuje argumenty podobne do `UseHealthChecks` . Zaletą korzystania z tej funkcji `MapHealthChecks` `UseHealthChecks` jest możliwość zastosowania autoryzacji i zwiększenia szczegółowej kontroli nad pasującymi zasadami.

W poniższym przykładzie `MapHealthChecks` jest wywoływana dla punktu końcowego sprawdzania kondycji w `/healthz` :

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHealthChecks("/healthz", new HealthCheckOptions() { });
    });
}
```

<a name="hostb"></a>

## <a name="hostbuilder-replaces-webhostbuilder"></a>HostBuilder zastępuje WebHostBuilder

Szablony ASP.NET Core 3,0 korzystają z [hosta ogólnego](xref:fundamentals/host/generic-host). Poprzednie wersje używają [hosta sieci Web](xref:fundamentals/host/web-host). Poniższy kod przedstawia klasę ASP.NET Core 3,0 wygenerowaną przez szablon `Program` :

[!code-csharp[](22-to-30/samples/Program.cs?name=snippet)]

Poniższy kod przedstawia klasę ASP.NET Core 2,2 wygenerowaną przez szablon `Program` :

[!code-csharp[](22-to-30/samples/Program2.2.cs?name=snippet)]

<xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder> pozostanie w 3,0 i jest typem `webBuilder` widocznym w poprzednim przykładzie kodu. <xref:Microsoft.AspNetCore.Hosting.WebHostBuilder> będzie przestarzałe w przyszłej wersji i zastąpione przez `HostBuilder` .

Najbardziej znacząca zmiana z `WebHostBuilder` do na `HostBuilder` jest [iniekcją zależności (di)](xref:fundamentals/dependency-injection). W przypadku korzystania `HostBuilder` z programu można wstrzyknąć tylko następujące elementy do `Startup` konstruktora:

* <xref:Microsoft.Extensions.Configuration.IConfiguration>
* <xref:Microsoft.Extensions.Hosting.IHostEnvironment>
* <xref:Microsoft.AspNetCore.Hosting.IWebHostEnvironment>

`HostBuilder`Ograniczenia di:

* Zezwól na kompilowanie kontenera DI tylko raz.
* Pozwala uniknąć problemów z okresem istnienia obiektów, takich jak rozpoznawanie wielu wystąpień pojedynczych.

Aby uzyskać więcej informacji, zobacz [unikanie iniekcji usługi uruchamiania w ASP.NET Core 3](https://andrewlock.net/avoiding-startup-service-injection-in-asp-net-core-3/).

## <a name="addauthorization-moved-to-a-different-assembly"></a>Element addauthorization został przeniesiony do innego zestawu

ASP.NET Core 2,2 i niższa `AddAuthorization` Metoda w *Microsoft.AspNetCore.Authorization.dll*:

* Zmieniono nazwę `AddAuthorizationCore` .
* Zostały przeniesione do *Microsoft.AspNetCore.Authorization.Policy.dll*.

Nie ma to wpływu na aplikacje używające zarówno *Microsoft.AspNetCore.Authorization.dll* , jak i *Microsoft.AspNetCore.Authorization.Policy.dll* .

Aplikacje, które nie używają *Microsoft.AspNetCore.Authorization.Policy.dll* powinny wykonać jedną z następujących czynności:

* Dodaj odwołanie do *Microsoft.AspNetCore.Authorization.Policy.dll*. Ta metoda działa w przypadku większości aplikacji i jest wymagana.
* Przełącz do korzystania z `AddAuthorizationCore`

Aby uzyskać więcej informacji, zobacz artykuł dotyczący [nadmiernej zmiany w programie `AddAuthorization(o =>` ) w innym zestawie #386](https://github.com/aspnet/Announcements/issues/386).

## <a name="identity-ui"></a>Identity INTERFEJSU użytkownika

Identity Aktualizacje interfejsu użytkownika dla ASP.NET Core 3,0:

* Dodaj odwołanie do pakietu do [Microsoft. AspNetCore. Identity . Interfejs użytkownika](https://nuget.org/packages/Microsoft.AspNetCore.Identity.UI).
* Aplikacje, które nie korzystają ze Razor stron, muszą wywoływać `MapRazorPages` . Zobacz [ Razor strony](#razor-pages) w tym dokumencie.
* Uruchomienie Bootstrap 4 jest domyślną strukturą interfejsu użytkownika. Ustaw `IdentityUIFrameworkVersion` Właściwość projektu w celu zmiany wartości domyślnej. Aby uzyskać więcej informacji, zobacz [ten anons usługi GitHub](https://github.com/aspnet/Announcements/issues/380).

## SignalR

SignalRKlient JavaScript zmienił `@aspnet/signalr` się z na `@microsoft/signalr` . Aby reagować na tę zmianę, Zmień odwołania w *package.jsw* plikach, `require` instrukcjach i `import` instrukcjach języka ECMAScript.

### <a name="systemtextjson-is-the-default-protocol"></a>System.Text.Jsjest domyślnym protokołem

`System.Text.Json` jest teraz domyślnym protokołem centrum używanym przez klienta i serwer.

W programie `Startup.ConfigureServices` Wywołaj polecenie, `AddJsonProtocol` Aby ustawić opcje serializatora.

**Server**

```csharp
services.AddSignalR(...)
        .AddJsonProtocol(options =>
        {
            options.PayloadSerializerOptions.WriteIndented = false;
        })
```

**Klient**

```csharp
new HubConnectionBuilder()
    .WithUrl("/chathub")
    .AddJsonProtocol(options =>
    {
        options.PayloadSerializerOptions.WriteIndented = false;
    })
    .Build();
```

### <a name="switch-to-newtonsoftjson"></a>Przełącz do Newtonsoft.Jsna

Jeśli używasz [funkcji Newtonsoft.Jsw programie, które nie są obsługiwane w programie System.Text.Json](/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to), możesz przełączyć się z powrotem do systemu `Newtonsoft.Json` . Zobacz [używanie Newtonsoft.Jsw programie w SignalR projekcie ASP.NET Core 3,0](#use-newtonsoftjson-in-an-aspnet-core-30-signalr-project) wcześniej w tym artykule.

## <a name="redis-distributed-caches"></a>Rozproszone pamięci podręczne Redis

Pakiet [Microsoft. Extensions. buforowania. Redis](https://www.nuget.org/packages/Microsoft.Extensions.Caching.Redis) nie jest dostępny dla aplikacji ASP.NET Core 3,0 lub nowszych. Zastąp odwołanie do pakietu pakietem [Microsoft. Extensions. buforowanie. StackExchangeRedis](https://www.nuget.org/packages/Microsoft.Extensions.Caching.StackExchangeRedis). Aby uzyskać więcej informacji, zobacz <xref:performance/caching/distributed>.

## <a name="opt-in-to-runtime-compilation"></a>Zezwól na kompilację środowiska uruchomieniowego

Przed ASP.NET Core 3,0, kompilacja widoków w środowisku uruchomieniowym była niejawną funkcją struktury. Kompilacja środowiska uruchomieniowego uzupełnia kompilację widoków w czasie kompilacji. Umożliwia ona programowi Kompilowanie Razor widoków i stron (plików *. cshtml* ), gdy pliki są modyfikowane, bez konieczności ponownego kompilowania całej aplikacji. Ta funkcja obsługuje scenariusz tworzenia szybkiej edycji w środowisku IDE i odświeżania przeglądarki w celu wyświetlenia zmian.

W ASP.NET Core 3,0, Kompilacja środowiska uruchomieniowego jest scenariuszem wyboru. Kompilacja czasu kompilacji jest jedynym mechanizmem kompilacji, który jest domyślnie włączony. Środowisko uruchomieniowe korzysta z programu Visual Studio lub [dotnet-Watch](xref:tutorials/dotnet-watch) w Visual Studio Code, aby ponownie skompilować projekt po wykryciu zmian w plikach *. cshtml* . W programie Visual Studio zmiany w plikach *CS*, *cshtml* lub *. Razor* w projekcie są uruchamiane (<kbd>Ctrl + F5</kbd>), ale nie są debugowane (<kbd>F5</kbd>), wyzwalają ponowną kompilację projektu.

Aby włączyć kompilację środowiska uruchomieniowego w projekcie ASP.NET Core 3,0:

1. Zainstaluj [pakiet Microsoft. AspNetCore. MVC. Razor . ](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation) Pakiet NuGet RuntimeCompilation.
1. Aktualizacja `Startup.ConfigureServices` do wywołania `AddRazorRuntimeCompilation` :

    W przypadku ASP.NET Core MVC Użyj następującego kodu:

    ```csharp
    services.AddControllersWithViews()
        .AddRazorRuntimeCompilation(...);
    ```
 
    W przypadku Razor stron ASP.NET Core Użyj następującego kodu:
 
    ```csharp
    services.AddRazorPages()
        .AddRazorRuntimeCompilation(...);
    ```
 
W przykładzie https://github.com/aspnet/samples/tree/master/samples/aspnetcore/mvc/runtimecompilation pokazano przykład włączania kompilacji środowiska uruchomieniowego warunkowo w środowiskach programistycznych.

Aby uzyskać więcej informacji na temat Razor kompilowania plików, zobacz <xref:mvc/views/view-compilation> .

## <a name="migrate-libraries-via-multi-targeting"></a>Migrowanie bibliotek poprzez wiele elementów docelowych

Biblioteki często muszą obsługiwać wiele wersji ASP.NET Core. Większość bibliotek, które zostały skompilowane przed poprzednimi wersjami ASP.NET Core, powinna działać bez problemów. Następujące warunki wymagają, aby aplikacja była skompilowana w sposób krzyżowy:

* Biblioteka korzysta z funkcji, która ma istotną [zmianę](#breaking-api-changes)w postaci binarnej.
* Biblioteka chce korzystać z nowych funkcji w ASP.NET Core 3,0. 

Na przykład:

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFrameworks>netcoreapp3.0;netstandard2.0</TargetFrameworks>
  </PropertyGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netcoreapp3.0'">
    <FrameworkReference Include="Microsoft.AspNetCore.App" />
  </ItemGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netstandard2.0'">
    <PackageReference Include="Microsoft.AspNetCore" Version="2.1.0" />
  </ItemGroup>
</Project>
```

Użyj `#ifdefs` , aby włączyć interfejsy API specyficzne dla ASP.NET Core 3,0:

```csharp
var webRootFileProvider =
#if NETCOREAPP3_0
    GetRequiredService<IWebHostEnvironment>().WebRootFileProvider;
#elif NETSTANDARD2_0
    GetRequiredService<IHostingEnvironment>().WebRootFileProvider;
#else
#error unknown target framework
#endif
```

Aby uzyskać więcej informacji na temat używania interfejsów API ASP.NET Core w bibliotece klas, zobacz <xref:fundamentals/target-aspnetcore> .

## <a name="miscellaneous-changes"></a>Różne zmiany

System sprawdzania poprawności w programie .NET Core 3,0 lub nowszy traktuje parametry niedopuszczające wartości null lub właściwości powiązane tak, jakby miały `[Required]` atrybut. Aby uzyskać więcej informacji, zobacz [[Required] Attribute](xref:mvc/models/validation?view=aspnetcore-3.1#required-attribute).

### <a name="publish"></a>Publikowanie

Usuń foldery *bin* i *obj* w katalogu projektu.

## <a name="testserver"></a>TestServer

W przypadku aplikacji, które używają <xref:Microsoft.AspNetCore.TestHost.TestServer> bezpośrednio z [hostem ogólnym](xref:fundamentals/host/web-host), Utwórz za pomocą `TestServer` <xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder> w <xref:Microsoft.Extensions.Hosting.GenericHostWebHostBuilderExtensions.ConfigureWebHost%2A> :

```csharp
[Fact]
public async Task GenericCreateAndStartHost_GetTestServer()
{
    using var host = await new HostBuilder()
        .ConfigureWebHost(webBuilder =>
        {
            webBuilder
                .UseTestServer()
                .Configure(app => { });
        })
    .StartAsync();

    var response = await host.GetTestServer().CreateClient().GetAsync("/");

    Assert.Equal(HttpStatusCode.NotFound, response.StatusCode);
}
```

<a name="break"></a>

## <a name="breaking-api-changes"></a>Przerywanie zmian interfejsu API

Przejrzyj istotne zmiany:

* [Pełna lista istotnych zmian w wersji 3,0 ASP.NET Core](https://github.com/aspnet/Announcements/issues?page=1&q=is%3Aissue+is%3Aopen+label%3A%22Breaking+change%22+label%3A3.0.0)
* [Przerywanie zmian interfejsu API w ramach funkcji "antysfałszowanych", mechanizmu CORS, diagnostyki, MVC i routingu](https://github.com/aspnet/Announcements/issues/387). Ta lista zawiera istotne zmiany dotyczące przełączników zgodności.
* Aby uzyskać podsumowanie dotyczące podziału od 2,2 do 3,0 na platformie .NET Core, ASP.NET Core i Entity Framework Core, zobacz istotne [zmiany dotyczące migracji z wersji 2,2 do 3,0](/dotnet/core/compatibility/2.2-3.0).

## <a name="endpoint-routing-with-catch-all-parameter"></a>Routing punktów końcowych za pomocą parametru catch-all

[!INCLUDE[](~/includes/catchall.md)]

## <a name="net-core-30-on-azure-app-service"></a>.NET Core 3,0 na Azure App Service

Wdrażanie programu .NET Core do Azure App Service zostało zakończone. Środowisko .NET Core 3,0 jest dostępne we wszystkich Azure App Service centrach danych.
