---
title: Hierarchia przeznaczenia i Wielodostępność w ASP.NET Core
author: rick-anderson
description: Dowiedz się więcej o hierarchii ciągów przeznaczenie i wielu dzierżawcach, które odnoszą się do ASP.NET Core interfejsów API ochrony danych.
ms.author: riande
ms.date: 10/14/2016
no-loc:
- cookie
- Cookie
- Blazor
- Blazor Server
- Blazor WebAssembly
- Identity
- Let's Encrypt
- Razor
- SignalR
uid: security/data-protection/consumer-apis/purpose-strings-multitenancy
ms.openlocfilehash: 4d442d3020c0d67b40ebd101442e5c84dcd4dbc6
ms.sourcegitcommit: 497be502426e9d90bb7d0401b1b9f74b6a384682
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 08/08/2020
ms.locfileid: "88022228"
---
# <a name="purpose-hierarchy-and-multi-tenancy-in-aspnet-core"></a><span data-ttu-id="49ee3-103">Hierarchia przeznaczenia i Wielodostępność w ASP.NET Core</span><span class="sxs-lookup"><span data-stu-id="49ee3-103">Purpose hierarchy and multi-tenancy in ASP.NET Core</span></span>

<span data-ttu-id="49ee3-104">Ponieważ `IDataProtector` występuje również niejawnie `IDataProtectionProvider` , cele mogą być łańcucha ze sobą.</span><span class="sxs-lookup"><span data-stu-id="49ee3-104">Since an `IDataProtector` is also implicitly an `IDataProtectionProvider`, purposes can be chained together.</span></span> <span data-ttu-id="49ee3-105">W tym sensie `provider.CreateProtector([ "purpose1", "purpose2" ])` jest równoważne `provider.CreateProtector("purpose1").CreateProtector("purpose2")` .</span><span class="sxs-lookup"><span data-stu-id="49ee3-105">In this sense, `provider.CreateProtector([ "purpose1", "purpose2" ])` is equivalent to `provider.CreateProtector("purpose1").CreateProtector("purpose2")`.</span></span>

<span data-ttu-id="49ee3-106">Pozwala to na niektóre interesujące relacje hierarchiczne za pomocą systemu ochrony danych.</span><span class="sxs-lookup"><span data-stu-id="49ee3-106">This allows for some interesting hierarchical relationships through the data protection system.</span></span> <span data-ttu-id="49ee3-107">We wcześniejszym przykładzie [contoso. Messaging. SecureMessage](xref:security/data-protection/consumer-apis/purpose-strings#data-protection-contoso-purpose)składnik SecureMessage może wywoływać się `provider.CreateProtector("Contoso.Messaging.SecureMessage")` po pierwszym z nich i przechować wynik w polu prywatnym `_myProvider` .</span><span class="sxs-lookup"><span data-stu-id="49ee3-107">In the earlier example of [Contoso.Messaging.SecureMessage](xref:security/data-protection/consumer-apis/purpose-strings#data-protection-contoso-purpose), the SecureMessage component can call `provider.CreateProtector("Contoso.Messaging.SecureMessage")` once up-front and cache the result into a private `_myProvider` field.</span></span> <span data-ttu-id="49ee3-108">Przyszłe funkcje ochrony można następnie tworzyć za pomocą wywołań do `_myProvider.CreateProtector("User: username")` , a te funkcje ochrony będą używane do zabezpieczania poszczególnych komunikatów.</span><span class="sxs-lookup"><span data-stu-id="49ee3-108">Future protectors can then be created via calls to `_myProvider.CreateProtector("User: username")`, and these protectors would be used for securing the individual messages.</span></span>

<span data-ttu-id="49ee3-109">Można to również przerzucić.</span><span class="sxs-lookup"><span data-stu-id="49ee3-109">This can also be flipped.</span></span> <span data-ttu-id="49ee3-110">Rozważ użycie pojedynczej aplikacji logicznej, która hostuje wiele dzierżawców (w przypadku usługi CMS jest to uzasadnione), a każda dzierżawa może być skonfigurowana z własnym systemem zarządzania uwierzytelnianiem i stanem.</span><span class="sxs-lookup"><span data-stu-id="49ee3-110">Consider a single logical application which hosts multiple tenants (a CMS seems reasonable), and each tenant can be configured with its own authentication and state management system.</span></span> <span data-ttu-id="49ee3-111">Aplikacja parasola ma jednego dostawcę głównego i wywołuje `provider.CreateProtector("Tenant 1")` i `provider.CreateProtector("Tenant 2")` zapewnia każdemu dzierżawcowi swój własny izolowany wycink systemu ochrony danych.</span><span class="sxs-lookup"><span data-stu-id="49ee3-111">The umbrella application has a single master provider, and it calls `provider.CreateProtector("Tenant 1")` and `provider.CreateProtector("Tenant 2")` to give each tenant its own isolated slice of the data protection system.</span></span> <span data-ttu-id="49ee3-112">Dzierżawcy mogą następnie utworzyć własne osoby chroniące przed własnymi potrzebami, ale bez względu na to, w jaki sposób nie mogą oni tworzyć funkcji ochrony, które kolidują z innymi dzierżawcami w systemie.</span><span class="sxs-lookup"><span data-stu-id="49ee3-112">The tenants could then derive their own individual protectors based on their own needs, but no matter how hard they try they cannot create protectors which collide with any other tenant in the system.</span></span> <span data-ttu-id="49ee3-113">Graficznie jest to reprezentowane poniżej.</span><span class="sxs-lookup"><span data-stu-id="49ee3-113">Graphically, this is represented as below.</span></span>

![Cele z wielu dzierżawców](purpose-strings-multitenancy/_static/purposes-multi-tenancy.png)

>[!WARNING]
> <span data-ttu-id="49ee3-115">Przyjęto założenie, że aplikacja parasola kontroluje, które interfejsy API są dostępne dla poszczególnych dzierżawców, a dzierżawcy nie mogą wykonać dowolnego kodu na serwerze.</span><span class="sxs-lookup"><span data-stu-id="49ee3-115">This assumes the umbrella application controls which APIs are available to individual tenants and that tenants cannot execute arbitrary code on the server.</span></span> <span data-ttu-id="49ee3-116">Jeśli dzierżawca może wykonać dowolny kod, może wykonać prywatne odbicie, aby przerwać gwarancje izolacji lub bezpośrednio odczytać główny materiał kluczający, a także utworzyć wszystkie podklucze, których chcą.</span><span class="sxs-lookup"><span data-stu-id="49ee3-116">If a tenant can execute arbitrary code, they could perform private reflection to break the isolation guarantees, or they could just read the master keying material directly and derive whatever subkeys they desire.</span></span>

<span data-ttu-id="49ee3-117">System ochrony danych w rzeczywistości używa sortowania wielu dzierżawców w domyślnej konfiguracji wbudowanej.</span><span class="sxs-lookup"><span data-stu-id="49ee3-117">The data protection system actually uses a sort of multi-tenancy in its default out-of-the-box configuration.</span></span> <span data-ttu-id="49ee3-118">Domyślnie główny materiał klucza jest przechowywany w folderze profilu użytkownika konta procesu roboczego (lub w rejestrze dla tożsamości puli aplikacji IIS).</span><span class="sxs-lookup"><span data-stu-id="49ee3-118">By default master keying material is stored in the worker process account's user profile folder (or the registry, for IIS application pool identities).</span></span> <span data-ttu-id="49ee3-119">Jest to jednak dość powszechne, aby użyć jednego konta do uruchamiania wielu aplikacji, a w związku z tym wszystkie te aplikacje spowodują utworzenie głównego materiału klucza.</span><span class="sxs-lookup"><span data-stu-id="49ee3-119">But it's actually fairly common to use a single account to run multiple applications, and thus all these applications would end up sharing the master keying material.</span></span> <span data-ttu-id="49ee3-120">Aby rozwiązać ten problem, system ochrony danych automatycznie wstawia unikatowy identyfikator dla poszczególnych aplikacji jako pierwszy element w łańcuchu ogólnego przeznaczenia.</span><span class="sxs-lookup"><span data-stu-id="49ee3-120">To solve this, the data protection system automatically inserts a unique-per-application identifier as the first element in the overall purpose chain.</span></span> <span data-ttu-id="49ee3-121">To niejawne przeznaczenie służy do [izolowania poszczególnych aplikacji](xref:security/data-protection/configuration/overview#per-application-isolation) przez efektywne traktowanie każdej aplikacji jako unikatowej dzierżawy w systemie, a proces tworzenia funkcji ochrony jest identyczny z powyższym obrazem.</span><span class="sxs-lookup"><span data-stu-id="49ee3-121">This implicit purpose serves to [isolate individual applications](xref:security/data-protection/configuration/overview#per-application-isolation) from one another by effectively treating each application as a unique tenant within the system, and the protector creation process looks identical to the image above.</span></span>
